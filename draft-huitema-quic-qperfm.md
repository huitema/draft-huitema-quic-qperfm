---
###
# Internet-Draft Markdown Template
#
# Rename this file from draft-todo-yourname-protocol.md to get started.
# Draft name format is "draft-<yourname>-<workgroup>-<name>.md".
#
# For initial setup, you only need to edit the first block of fields.
# Only "title" needs to be changed; delete "abbrev" if your title is short.
# Any other content can be edited, but be careful not to introduce errors.
# Some fields will be set automatically during setup if they are unchanged.
#
# Don't include "-00" or "-latest" in the filename.
# Labels in the form draft-<yourname>-<workgroup>-<name>-latest are used by
# the tools to refer to the current version; see "docname" for example.
#
# This template uses kramdown-rfc: https://github.com/cabo/kramdown-rfc
# You can replace the entire file if you prefer a different format.
# Change the file extension to match the format (.xml for XML, etc...)
#
###
title: "QUIC Multimedia Performance"
abbrev: "QUIC-Perf-Multimedia"
category: info

docname: draft-huitema-quic-qperfm-latest
submissiontype: IETF  # also: "independent", "editorial", "IAB", or "IRTF"
number:
date:
consensus: true
v: 3
area: AREA
workgroup: WG Working Group
keyword:
 - next generation
 - unicorn
 - sparkling distributed ledger
venue:
  group: WG
  type: Working Group
  mail: WG@example.com
  arch: https://example.com/WG
  github: USER/REPO
  latest: https://example.com/LATEST

author:
 -
    fullname: Christian Huitema
    organization: Private Octopus Inc
    email: huitema@huitema.net

normative:

informative:
    I-D.banks-quic-performance:


--- abstract

The QUIC multimedia performance protocol (QPERFM) updates the QUIC performance
protocol (QPERF). QPERF provides a simple, general-purpose
protocol for testing the performance characteristics of a QUIC
implementation. QPERFM updates that protocol to simulate the traffic
of multimedia application and measure performance in a multi-media
oriented way.


--- middle

# Introduction

The QUIC performance protocol (QUIC Perf) defined in {{I-D.banks-quic-performance}} provides
a simple, general-purpose
protocol for testing the performance characteristics of a QUIC
implementation. This draft extends QPERF to allow simulation and
performance measurement of a variety of multimedia applications.


The original QUIC Perf protocol was very simple. The client opens QUIC connection with
the ALPN set to "perf", and then it opens bidirectional streams.
The first 8 bytes sent by the client on each stream
encode the size of the data that the server will send
on the return stream. This can be used to measure batch performance, simply requesting
a large amount of data and measuring how long it takes to get the result. It can also
be used to measure transactional applications: open a large number of streams,
require a small amount of data on each, and measure how long it takes to process
that many query-reponse exchanges.

We extended this simple protocol to also test "real time" workloads,
such as would be generated by "rMmedia over QUIC" (moq). Instead of using the first 8
bytes of a bidirectional stream to merely specify a number of bytes, we use the
first 16 bytes of the stream to specify the characteristics of a media stream. We
set the first 4 bytes to a reserved value, so the server can distinguish
QPERFM requests from QPERF requests.

# Conventions and Definitions

{::boilerplate bcp14-tagged}

# QUIC Perf protocol Extensions for Multimedia

The standard QPerf protocol uses bidirectional streams in a very simple way: the client
opens a stream and starts sending data; the server reads the number of required bytes in
the first 8 bytes of the client stream, and sends that many bytes to the client. We extend
this protocol by using unidirectional streams and datagrams.

The extended QPerf protocol also uses bidirectional streams. The first 16 bytes sent by the
client encode the type of response expected by the sender. The first 8 bytes use reserved
values to differentiate these streams from the standard "batch" stream:

* The most significant 32 bits contain the value 0xFFFFFFFD to indicate a "media"
  request, or 0xFFFFFFFE to indicate a datagram request.
* The lower 32 bits contain the size of the frames.

The complete set of 16 bytes is defined as:

~~~
media request header {
     media or datagram mark (32),
     frame size (32),
     priority (8),
     frequency (8),
     number of frames (24),
     first frame size (24)
}
~~~

Upon receiving a request header, the server will start sending
frames as specified by the frequency. If the client requested
datagrams, the server will send datagrams as specified by the
frequency. The first datagram (frame number 0) will be sent
immediately. The other datagrams will be sent at:

~~~
datagram_send_time = first_datagram_send_time
                   + frame_number*1_second/frequency
~~~

Each datagram will carry a header and a payload, with a combined size
set to the requested frame size. (The first frame size parameter is
ignored for datagrams.) The first bytes of the datagram contain a
header encoded as:

~~~
datagram header {
    request stream ID (i),
    frame number (i),
    datagram send time (64)
}
~~~

The datagram send time is the local time at the server, encoded in microseconds.
When all datagrams have been sent, the server closes the media request stream.

If the client requested a "media" stream, the server will send the requested
number of frames on the return side of the bilateral stream that carried the
client request. The first frame contains "first frame size" bytes, while the
other frames contain "frame size" bytes. The first frame is queued on the
stream immediately. The next frames will be queued at:

~~~
frame_send_time = first_frame_send_time
                + frame_number*1_second/frequency
~~~

The first 8 bytes of each frame carry the `frame_send_time`, set at the
local time at which the server queued the frame, expressed in microseconds
and encoded on 64 bits.

The client may issue a `stop sending` request for a specific media request
stream. Upon receiving the request, the server will reset the stream, without
sending any additional frame.

## Client side measurements

The client can simulate complex scenarios by opening a series of streams
and direct the server to send as many media streams. The client
can parse the incoming data and extract statistics such as arrival time of
different frames, latencies, etc.

# Security Considerations

Since the performance protocol allows for a client to trivially
request the server to do a significant amount of work, it's generally
advisable not to deploy a server running this protocol on the open
internet.

One possible mitigation for unauthenticated clients generating an
unacceptable amount of work on the server would be to use client
certificates to authenticate the client first.


# IANA Considerations

This document has no IANA actions.


--- back

# Acknowledgments
{:numbered="false"}

This draft extends Nick Banks original specification of QUIC Perf,
and incorporates some of the text in that original draft.
